#this file will handle game logic such as handling inputs and opening inventory
#he will tall to other processors by changing a single bank

define data bank1

define player_pos_adress 0
define axises_adress 5
define player_cam_rot_adress 3

define points_len_adress 14
define faces_len_adress 15
define points_proj_adress 16

define key_W switch1
define key_A switch2
define key_S switch3
define key_D switch4

define right_click switch5
define left_click switch6

define mouse_right switch7
define mouse_left switch8
define mouse_up switch9
define mouse_down switch10

define space switch11
define shift switch12



player_x_pos_adr = player_pos_adress
player_y_pos_adr = player_pos_adress + 1
player_z_pos_adr = player_pos_adress + 2


jump defined is_defined == 1
    R_x = 0
    R_y = 0
    
    pos_x = 0
    pos_y = 0
    pos_z = -5
    
    data[player_x_pos_adr] = pos_x
    data[player_y_pos_adr] = pos_y
    data[player_z_pos_adr] = pos_z
    
    is_defined = 1
    
    jump calculate_rotation_axises always

:defined


jump W_false key_W.enabled == 0
    data[player_z_pos_adr] = data[player_z_pos_adr] + forward_axis_z
    data[player_x_pos_adr] = data[player_x_pos_adr] + forward_axis_x
:W_false

jump A_false key_A.enabled == 0
    data[player_z_pos_adr] = data[player_z_pos_adr] - XAxis_z
    data[player_x_pos_adr] = data[player_x_pos_adr] - XAxis_x
:A_false

jump S_false key_S.enabled == 0
    data[player_z_pos_adr] = data[player_z_pos_adr] - forward_axis_z
    data[player_x_pos_adr] = data[player_x_pos_adr] - forward_axis_x
:S_false

jump D_false key_D.enabled == 0
    data[player_z_pos_adr] = data[player_z_pos_adr] + XAxis_z
    data[player_x_pos_adr] = data[player_x_pos_adr] + XAxis_x
:D_false

jump space_false space.enabled == 0
    data[player_y_pos_adr] = data[player_y_pos_adr] + 0.05
:space_false

jump shift_false space.enabled == 0
    data[player_y_pos_adr] = data[player_y_pos_adr] - 0.05
:shift_false

jump up_false mouse_up.enabled == 0
    R_y = R_y + 1
    jump calculate_rotation_axises always
:up_false

jump down_false mouse_down.enabled == 0
    R_y = R_y - 1
    jump calculate_rotation_axises always
:down_false

jump right_false mouse_right.enabled == 0
    R_x = R_x + 1
    jump calculate_rotation_axises always
:right_false

jump left_false mouse_left.enabled == 0
    R_x = R_x - 1
    jump calculate_rotation_axises always
:left_false

end

:calculate_rotation_axises
    data[player_cam_rot_adress] = R_x
    data[player_cam_rot_adress + 1] = R_y

    #calculate local Axises
    XAxis_x = cos(R_x)
    XAxis_y = 0
    XAxis_z = -sin(R_x)
    
    data[axises_adress] = XAxis_x
    data[axises_adress + 1] = XAxis_y
    data[axises_adress + 2] = XAxis_z
    
    horizontal_len = sin(R_y)
    YAxis_x = -sin(R_x) * horizontal_len
    YAxis_y = cos(R_y)
    YAxis_z = -cos(R_x) * horizontal_len
    
    data[axises_adress + 3] = YAxis_x
    data[axises_adress + 4] = YAxis_y
    data[axises_adress + 5] = YAxis_z
    
    horizontal_len = cos(R_y)
    ZAxis_x = sin(R_x) * horizontal_len
    ZAxis_y = sin(R_y)
    ZAxis_z = cos(R_x) * horizontal_len
    
    data[axises_adress + 6] = ZAxis_x
    data[axises_adress + 7] = ZAxis_y
    data[axises_adress + 8] = ZAxis_z
    
    forward_axis_x = -XAxis_z * 0.005
    forward_axis_z = XAxis_x * 0.05
